from glob import iglob
from multiprocessing import Pool
from os.path import abspath, normpath, join
from shlex import quote
from subprocess import PIPE, getoutput, run

import pandas as pd
from elftools.elf.elffile import ELFFile
from parse import compile
from reil.x86.translator import translate

from acevm import REILApproximateVM, REILMemContext, REILRegContext


def get_line_number(filename, funcname):
    found = False
    cmd = "ctags -x --c-kinds=f " + filename + " | grep " + funcname

    output = getoutput(cmd)
    lines = output.splitlines()

    for line in lines:
        if line.startswith(funcname + " "):
            found = True

            if output.strip() != "":
                output = output.split(" ")
                lines = list(filter(None, output))
                line_num = lines[2]

                # print("Function found in file " + filename + " on line: " + line_num)
                return int(line_num)

    if found == False:
        # print("Function not found")
        return 0


def get_function_source_dir(function_name, source_code_dir):
    """
    Searches an entire source directory for the named function,
    stopping as soon as one is encountered and returning its
    source code.
    """
    for filename in iglob(source_code_dir + "/**/*.c", recursive=True):
        line_num = get_line_number(filename, function_name)

        if line_num > 0:
            return extract_function_at_line(filename, line_num)

    # Didn't find anything in the .c files, now we'll check the .h file
    for filename in iglob(source_code_dir + "/**/*.h", recursive=True):
        line_num = get_line_number(filename, function_name)

        if line_num > 0:
            return extract_function_at_line(filename, line_num)

    # If we get here, then we never found the function
    print("Function {} not found within {}".format(function_name, source_code_dir))


def extract_function_at_line(filename, line_num):
    code = ""
    cnt_braket = 0
    found_start = False
    found_end = False
    try:
        with open(filename, "r") as f:
            for i, line in enumerate(f):
                if i >= (line_num - 1):
                    code += line

                    if line.count("{") > 0:
                        found_start = True
                        cnt_braket += line.count("{")

                    if line.count("}") > 0:
                        cnt_braket -= line.count("}")

                    if cnt_braket == 0 and found_start == True:
                        found_end = True
                        return code
    except FileNotFoundError:
        print("WARN: {} does not exist".format(filename))
        return


def get_function_source(function_name, source_file):
    line_num = get_line_number(source_file, function_name)
    return extract_function_at_line(source_file, line_num)


def nm_attribute_binary(binary_path): #nm_src_only):
    """
    Uses nm to identify and attribute as many functions as possible

    :param binary_path: path to the binary whose functions are to be attributed
    :param nm_src_only: set to True to only return functions that nm can attribute source to
    """
    # First, we need a ground truth list of functions. We'll use nm for this
    # C = demangle names, l = show line numbers, A = show binary path, P = POSIX format
    cmd = "nm -ClAP {} | grep -iw t".format(quote(binary_path))

#     # If enabled, only return symbols for which nm found source code
#     if nm_src_only:
#         cmd = cmd + " | grep [[:space:]]/"

    # Execute nm
    try:
        nm_output = run(
            cmd, shell=True, check=True, universal_newlines=True, stdout=PIPE
        ).stdout
    except CalledProcessError:
        print("Failed to run nm for " + binary_path)

    # Parse the output with pre-compiled parsers
    nm_parser = compile(
        "{binary}: {function} {nm_type:l} {address:x} {length:x}\t{src_path}:{src_line:d}"
    )
    nm_parser_nosrc = compile("{binary}: {function} {nm_type:l} {address:x} {length:x}")
    nm_parser_gcc = compile("{binary}: {function} {nm_type:l} {address:x} ")
    function_dicts = []
    for line in nm_output.splitlines():
        parsed = nm_parser.parse(line)
        if parsed is not None:
            # Hit a line with source information
            function_dict = parsed.named
            function_dict["attributor"] = "nm-" + function_dict["nm_type"]
            function_dicts.append(function_dict)
        else:
            # Hit a line without source information
            parsed = nm_parser_nosrc.parse(line)
            if parsed is not None:
                function_dicts.append(parsed.named)
            elif nm_parser_gcc.parse(line) is not None:
                # Ignore standard GCC helper functions like _fini()
                pass
            else:
                print("WARN: couldn't parse nm line: " + line)

    col_names = [
        "binary",
        "function",
        "address",
        "length",
        "src_path",
        "src_line",
        "src_code",
        "attributor",
        "raw_bytes",
        "fingerprint",
    ]
    return pd.DataFrame(function_dicts, columns=col_names)


def get_raw_bytes_f(bin_f, start, stop):
    """
    Get the raw bytes between two MEMORY addresses in an ELF binary
    
    :param bin_f: File object for the binary
    :param start: the starting address to extract
    :param stop: the last address to extract
    :returns: a raw bytes object
    """
    start_addr = list(ELFFile(bin_f).address_offsets(start))[0]
    bin_f.seek(start_addr)
    return bin_f.read(stop - start)


def x86_to_reil(raw_bytes):
    """
    Wrapper function. Returns output from REIL translator in human-readable format
    """
    return list(
        il_ins
        for nat_ins in translate(raw_bytes, 0x0, x86_64=False)
        for il_ins in nat_ins.il_instructions
    )


def x86_fingerprint_raw_bytes(raw_bytes, sort=True):
    avm = REILApproximateVM(REILRegContext.zeros, REILMemContext.address, True)
    reil_code = sorted(x86_to_reil(raw_bytes)) if sort else x86_to_reil(raw_bytes)
    for ins in reil_code:
        avm.execute(ins)
    return avm.t_regs


def x86_fingerprint_raw_bytes_nosort(raw_bytes):
    """Wrapper function for use with Pool.map."""
    return x86_fingerprint_raw_bytes(raw_bytes, sort=False)


def full_profile(binary_path, threads=6, ins_sort=True, src_only=False, src_path=None):
    """
    Extract a full profile of all functions in a given binary.
    
    :param threads: How many threads to use to process the binary
    :param ins_sort: If True, sort REIL instructions before running in aVM
    :param src_only: If True, drop functions that can't be attributed to source code (e.g. library functions)
    :param src_path: Absolute path to directory where binary was built, which contains the source code files. 
    This is useful when the binary's debugging symbols only contain relative (non-absolute) pathsto source files
    """
    base_table = nm_attribute_binary(binary_path)
    
    # Drop non-source-attributed functions if requested
    if src_only:
        base_table.dropna(subset=["src_path"], inplace=True)
    
    # Prepend source paths if requested
    if src_path is not None:
        filt = base_table.src_path.notnull()
        prefix = abspath(src_path)
        base_table.loc[filt, 'src_path'] = [
            normpath(join(prefix, x))
            for x in base_table.loc[filt, 'src_path']
        ]

    # Get source code for each function
    base_table["src_code"] = [
        extract_function_at_line(s, int(l)) if l >= 0 else None
        for s, l in zip(base_table["src_path"], base_table["src_line"])
    ]
    
    # Filter out source paths that couldn't be found
    filt = base_table.src_path.notnull() & base_table.src_code.isnull()
    base_table.loc[filt, 'src_path'] = None
    
    # Get raw bytes for each function 
    with open(binary_path, "rb") as f:
        base_table["raw_bytes"] = [
            get_raw_bytes_f(f, a, a + l) if l >= 0 else None
            for a, l in zip(base_table["address"], base_table["length"])
        ]
    
    # Fingerprint each function
    if threads == 1:
        base_table["fingerprint"] = [
            x86_fingerprint_raw_bytes(raw, ins_sort) for raw in base_table.raw_bytes
        ]
    else:
        with Pool(threads) as pool:
            if ins_sort:
                base_table["fingerprint"] = pool.map(
                    x86_fingerprint_raw_bytes, base_table.raw_bytes
                )
            else:
                base_table["fingerprint"] = pool.map(
                    x86_fingerprint_raw_bytes_nosort, base_table.raw_bytes
                )

    return base_table
